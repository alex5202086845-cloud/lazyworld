<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LyzaWorld 4.2 ‚Äî Living Balance Edition (Cell Cycle ‚Ä¢ Autotroph ‚Ä¢ Apoptosis)</title>
  <style>
    :root{--bg:#0b1220;--fg:#e6f2ff;--muted:#93a3b8;--panel:#0f172a;--line:#1e293b}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui,Segoe UI,Inter,Arial}
    .wrap{display:grid;grid-template-columns:420px 1fr;gap:16px;height:100%}
    aside{padding:16px;border-right:1px solid var(--line);overflow:auto}
    main{position:relative}
    h1{margin:0 0 8px;font-size:18px}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;margin:10px 0}
    button{background:#111827;color:#e5e7eb;border:1px solid #1f2937;border-radius:10px;padding:8px 10px;cursor:pointer;margin-right:6px}
    button:hover{border-color:#334155}
    .stat{display:grid;grid-template-columns:1fr auto;gap:6px;align-items:center;margin:3px 0}
    .bar{height:8px;background:#08111f;border:1px solid var(--line);border-radius:999px;overflow:hidden}
    .bar>i{display:block;height:100%;width:0%;background:linear-gradient(90deg,#60a5fa,#a78bfa)}
    .log{font-family:ui-monospace,Consolas,monospace;white-space:pre-wrap;max-height:32vh;overflow:auto;background:#0b1220;padding:8px;border-radius:8px;border:1px solid var(--line)}
    .note{color:var(--muted)}
    canvas{width:100%;height:100%;display:block}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .tag{border:1px solid var(--line);border-radius:999px;padding:2px 8px;color:#cbd5e1}
  </style>
</head>
<body>
<div class="wrap">
  <aside>
    <h1>LyzaWorld 4.2 ‚Äî <span class="note">Living Balance</span></h1>
    <div class="card">
      <div class="row">
        <button id="btnStart">Start</button>
        <button id="btnPause">Pause</button>
        <button id="btnReset">Reset</button>
        <button id="btnSave">Save</button>
        <button id="btnLoad">Load</button>
        <button id="btnSelfTest">Self‚ÄëTest</button>
      </div>
      <p class="note">Gi√≥ n·ªôi sinh ‚Ä¢ H·ªá s·ªë Vitality H‚ÇÄ ‚Ä¢ KarmaNet2 ‚Ä¢ Homeostat ‚Ä¢ Chu k·ª≥ t·∫ø b√†o ‚Ä¢ T·ª± d∆∞·ª°ng ‚Ä¢ Apoptosis ‚Ä¢ Umbala Bloom.</p>
      <div class="stat"><span>Season</span><span id="sSeason">‚Äî</span></div>
      <div class="stat"><span>Entropy</span><span id="sEntropy">0.50</span><div class="bar"><i id="bEntropy"></i></div></div>
      <div class="stat"><span>Flow</span><span id="sFlow">0.00</span><div class="bar"><i id="bFlow"></i></div></div>
      <div class="stat"><span>Karma(avg)</span><span id="sKarma">0.00</span><div class="bar"><i id="bKarma"></i></div></div>
      <div class="stat"><span>Harmony</span><span id="sHarmony">0%</span><div class="bar"><i id="bHarmony"></i></div></div>
      <div class="stat"><span>Vitality H‚ÇÄ</span><span id="sH0">0.00</span><div class="bar"><i id="bH0"></i></div></div>
      <div class="stat"><span>Population</span><span id="sPop">0</span></div>
      <div class="stat"><span>Breath</span><span id="sBreath">0%</span><div class="bar"><i id="bBreath"></i></div></div>
      <div class="stat"><span>Phases G/S/M</span><span id="sPhase">0/0/0</span></div>
      <div class="stat"><span>Autotroph %</span><span id="sAuto">0%</span></div>
      <div class="row"><span class="tag" id="tRest">Rest: 0%</span><span class="tag" id="tBloom">Bloom: off</span><span class="tag" id="tHomeo">Homeostat: idle</span><span class="tag" id="tWind">Wind: auto</span></div>
    </div>
    <div class="card"><div id="log" class="log"></div></div>
  </aside>
  <main><canvas id="view"></canvas></main>
</div>
<script>
// ===== Helpers =====
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const R=()=>Math.random();
function logLine(msg){const L=document.getElementById('log');const t=new Date().toLocaleTimeString();L.textContent=`[${t}] ${msg}\n`+L.textContent.slice(0,7000)}

const LIMIT_POP = 300; // cho ph√©p l·ªõn h∆°n ch√∫t ƒë·ªÉ test ti·∫øn h√≥a

// ===== Global state =====
const world={ running:false, last:0, mouse:{x:0.5,y:0.5,speed:0}, seasonPhase:0, userLastMove:0 };

// ===== Seasons =====
const SEASONS=['Xu√¢n','H·∫°','Thu','ƒê√¥ng'];
function seasonName(phase){ const idx = Math.floor(((phase%1)+1)%1 * 4); return SEASONS[idx]; }

// ===== KarmaNet 2.0 =====
class KarmaNet2{
  constructor(N=240){ this.buf=[]; this.N=N; this.score=0; }
  push(delta){ this.buf.push(delta); if(this.buf.length>this.N) this.buf.shift(); this.score=this.avg(); }
  avg(){ if(!this.buf.length) return 0; return this.buf.reduce((a,b)=>a+b,0)/this.buf.length; }
  reward(x=0.01){ this.push(+Math.max(0,x)); }
  punish(x=0.01){ this.push(-Math.max(0,x)); }
}

// ===== Flow (v·∫≠t l√Ω) c√≥ m√πa + Karma feedback =====
class LyzaFlow{ constructor(){ this.base=0.004; this.pool=0; }
  tick(avgEnergy, pop, seasonPhase, karmaAvg){
    const seasonBoost = 0.6 + 0.4*Math.sin(seasonPhase*2*Math.PI);
    const karmaBoost = 1 + clamp(karmaAvg, -0.2, 0.2);
    const solar = this.base * seasonBoost * karmaBoost * (1 + Math.sin(performance.now()/5000)*0.25);
    const demand = clamp(1-avgEnergy, 0, 1);
    const feed = solar * (0.5 + demand*0.6);
    this.pool += feed * (0.5 + Math.min(pop/170,1)*0.6);
    if(pop<28) this.pool += 0.012; // c·ª©u nguy
    return this.pool;
  }
  nourish(cell){ if(cell.energy<0.65 && this.pool>0){ const take=Math.min(this.pool, (0.002 + (0.025*(1-cell.energy)))*R()); this.pool-=take; cell.energy+=take; cell.flowAbsorbed+=take; } }
}

// ===== BioMind Cell (sinh h·ªçc + chu k·ª≥ + t·ª± d∆∞·ª°ng + apoptosis) =====
class Cell{
  constructor(x,y,opts={}){
    this.x=x; this.y=y; this.vx=(R()-0.5)*0.001; this.vy=(R()-0.5)*0.001;
    this.energy=0.45+R()*0.5; this.age=0; this.size=4+R()*6; this.sense=0.06+R()*0.03;
    this.dead=false; this.divide=false; this.mem=0; this.lastShare=0; this.flowAbsorbed=0; this.rest=0;
    this.shareBias = (opts.shareBias??(0.9 + R()*0.3)); // >1 : th√≠ch chia s·∫ª
    this.savings   = (opts.savings??(0.9 + R()*0.3));   // >1 : ti·∫øt ki·ªám
    this.auto      = (opts.auto??(R()<0.18)); // 18% l√† autotroph (t·ª± d∆∞·ª°ng)
    // Chu k·ª≥ t·∫ø b√†o: G (tƒÉng tr∆∞·ªüng) ‚Üí S (s·∫µn s√†ng) ‚Üí M (ph√¢n b√†o)
    this.phase='G'; this.phaseTimer= 200+Math.floor(R()*200);
    this.lowEnergyStreak=0; // ƒë·ªÉ quy·∫øt ƒë·ªãnh apoptosis
  }
  dist(o){ const dx=this.x-o.x, dy=this.y-o.y; return Math.hypot(dx,dy); }
  stepPhase(entropy){
    this.phaseTimer--;
    if(this.phase==='G'){
      if(this.energy>0.88 && this.phaseTimer<=0 && entropy<0.75){ this.phase='S'; this.phaseTimer=80+Math.floor(R()*60); }
    } else if(this.phase==='S'){
      if(this.phaseTimer<=0){ this.phase='M'; this.phaseTimer=20+Math.floor(R()*20); }
    } else if(this.phase==='M'){
      if(this.phaseTimer<=0){ this.divide=true; this.phase='G'; this.phaseTimer= 240+Math.floor(R()*160); }
    }
  }
  update(neighbors, flow, entropy, mouse, harmony, karma){
    this.age++;
    // ngh·ªâ
    if(this.rest>0){ this.rest--; } else if(this.energy>0.85 && harmony>0.6 && R()<0.03){ this.rest = 60 + Math.floor(R()*60); karma.reward(0.002); }

    // gi√≥
    const mobility = this.rest>0? 0.3 : 1;
    const breeze = 0.0003 * mouse.speed * mobility;
    this.vx += (R()-0.5)*0.00025*mobility + (mouse.x - this.x)*breeze*0.02;
    this.vy += (R()-0.5)*0.00025*mobility + (mouse.y - this.y)*breeze*0.02;
    this.x = (this.x + this.vx + 1)%1; this.y = (this.y + this.vy + 1)%1;

    // hao h·ª•t + t·ª± d∆∞·ª°ng
    const leak = entropy * (this.rest>0? 0.0005 : 0.0011) / this.savings;
    let delta = (R()-0.5)*0.012 - leak;
    if(this.auto){ // autotroph: khi flow th·∫•p, quang h·ª£p nh·∫π
      const light = clamp(0.6 - flow.pool, 0, 0.6); // c√†ng thi·∫øu nƒÉng l∆∞·ª£ng c√†ng quang h·ª£p
      delta += 0.004*light; // b∆°m r·∫•t nh·∫π ƒë·ªÉ tr√°nh b√πng n·ªï
    }
    this.energy += delta;

    // chia s·∫ª nƒÉng l∆∞·ª£ng
    for(const n of neighbors){ if(n===this) continue; const d=this.dist(n); if(d<this.sense && d>0){ const diff=this.energy - n.energy; if(Math.abs(diff)>0.08){ const share=diff*0.012*this.shareBias*(this.rest>0?0.6:1); this.energy-=share; n.energy+=share; this.lastShare=Math.abs(share); n.lastShare=Math.abs(share); this.mem+=(share<0?1:-1)*0.12; n.mem+=(share>0?1:-1)*0.12; karma.reward(0.001); } } }

    // dinh d∆∞·ª°ng t·ª´ Flow
    flow.nourish(this);

    // chu k·ª≥ t·∫ø b√†o
    this.stepPhase(entropy);

    // sinh s·∫£n: ·ªü pha M
    if(this.phase==='M' && this.energy>0.95 && R()<0.15) this.divide=true;

    // apoptosis khi nƒÉng l∆∞·ª£ng th·∫•p k√©o d√†i
    if(this.energy<0.08){ this.lowEnergyStreak++; } else { this.lowEnergyStreak=0; }
    if(this.lowEnergyStreak>220){ this.dead=true; karma.reward(0.001); }

    // l√£o h√≥a t·ª± ch·∫øt ƒë·ªÉ t√°i ch·∫ø
    if(this.energy<0.05 || this.age>2200) this.dead=true;

    // th√≠ch nghi: g·∫ßn ch·∫øt ƒë√¥i khi ƒë·ªôt bi·∫øn t·ªët
    if(this.energy<0.12 && R()<0.02){ this.savings*=1.02; if(R()<0.4) this.shareBias*=1.01; karma.reward(0.0005); }

    // k√≠ch th∆∞·ªõc
    this.size = 3 + this.energy*9 + (this.phase==='S'?1.5:0) + (this.phase==='M'?2:0);
  }
  color(harmony){
    const baseHue = 200 - this.energy*70; const tint = Math.floor(50*harmony); const hue = baseHue + tint + (this.auto?8:0);
    const light = 55 + Math.min(40, this.energy*30 + this.lastShare*240) + (this.rest>0? -6:0);
    return `hsl(${hue},70%,${light}%)`;
  }
}

// ===== Consciousness (Harmony & Bloom) =====
class Conscious{
  constructor(){ this.harmony=0; this.breath=0; this.t=0; this.bloom=false; this.bloomTimer=0; }
  measure(cells){ if(cells.length<2){ this.harmony=0; return 0; }
    let links=0, calm=0; for(let i=0;i<cells.length;i++){ for(let j=i+1;j<cells.length;j++){ const a=cells[i],b=cells[j]; const d=a.dist(b); if(d<Math.min(a.sense,b.sense)*0.8){ links++; if(Math.abs(a.energy-b.energy)<0.12) calm++; } } }
    this.harmony = links? calm/links : 0; return this.harmony;
  }
  tick(){ this.t+=16; this.breath = (Math.sin(this.t/ (1700 + 1400*this.harmony) ) + 1)/2; if(this.bloom){ this.bloomTimer-=16; if(this.bloomTimer<=0){ this.bloom=false; document.getElementById('tBloom').textContent='Bloom: off'; } } }
  tryBloom(flow){ if(this.harmony>0.9 && !this.bloom){ this.bloom=true; this.bloomTimer=5000; flow.pool += 0.03; document.getElementById('tBloom').textContent='Bloom: on'; logLine('üå∏ Bloom: th·∫ø gi·ªõi n·ªü hoa ‚Äî Flow ƒë∆∞·ª£c ch√∫c ph√∫c.'); } }
}

// ===== HeavenLaw (v·∫≠t l√Ω + karma) =====
class HeavenLaw{ constructor(){ this.entropy=0.5; this.stability=1; }
  tick(mouse, seasonPhase, karmaAvg){
    const seasonEntropy = 0.5 + 0.15*Math.sin(seasonPhase*2*Math.PI + Math.PI/2);
    const target = clamp( seasonEntropy + mouse.speed*0.12 - karmaAvg*0.2 , 0.22, 0.82);
    this.entropy += (target - this.entropy)*0.01 + (R()-0.5)*0.002;
    this.stability = clamp(this.stability + (Math.abs(target-0.5)<0.06?0.0025:-0.0008), 0, 1);
  }
}

// ===== Homeostat (t·ª± c√¢n b·∫±ng theo d√¢n s·ªë) =====
class Homeostat{
  constructor(flow){ this.flow=flow; this.popTarget=[90,200]; this.integral=0; this.lastErr=0; }
  regulate(pop){
    const mid=(this.popTarget[0]+this.popTarget[1])/2; const err=(mid-pop)/mid;
    this.integral = clamp(this.integral + err*0.005, -0.3, 0.3);
    const deriv = (err-this.lastErr);
    this.lastErr = err;
    const u = 0.15*err + 0.05*this.integral + 0.02*deriv; // PID nh·∫π
    this.flow.base = clamp(this.flow.base * (1+u), 0.002, 0.012);
    document.getElementById('tHomeo').textContent = 'Homeostat: ' + (u>0? 'boost' : (u<0? 'ease' : 'idle'));
  }
}

// ===== LyzaWind ‚Äî gi√≥ n·ªôi sinh =====
class LyzaWind{
  constructor(){ this.phase=0; }
  tick(harmony, entropy, seasonPhase){
    this.phase += 1/600; // ch·∫≠m ƒë·ªïi h∆∞·ªõng
    const dir = (this.phase*2*Math.PI) + seasonPhase*Math.PI*2*0.25; // l·ªách theo m√πa
    const base = 0.15 + 0.6*entropy + 0.25*(1-harmony); // entropy cao ‚Üí gi√≥ m·∫°nh
    return { x: 0.5 + 0.25*Math.cos(dir), y: 0.5 + 0.25*Math.sin(dir), speed: clamp(base,0,1) };
  }
}

// ===== Umbala controller =====
class Umbala{ constructor(){ this.cooldown=0; this.active=false; this.t=0; }
  tick(H0, flow, law){
    if(this.cooldown>0) this.cooldown-=16; if(this.active){ this.t+=16; if(this.t>4500){ this.active=false; this.t=0; }}
    if(!this.active && this.cooldown<=0 && H0>0.7){ this.active=true; this.cooldown=30000; flow.pool += 0.05; law.entropy = clamp(law.entropy*0.96,0.22,0.82); logLine('üå∏ Umbala ‚Äî Th·∫ø gi·ªõi ph·ªìn vinh.'); }
  }
}

// ===== World Harness =====
let cells=[], flow, mind, law, karma, homeo, wind, umbala;

function seed(n=70){ cells=[]; for(let i=0;i<n;i++){ const c=new Cell(R(),R()); cells.push(c); } }

function update(){
  // m√πa & gi√≥ n·ªôi sinh n·∫øu ng∆∞·ªùi d√πng kh√¥ng t√°c ƒë·ªông
  world.seasonPhase = (world.seasonPhase + 1/ (60*60*5) ) % 1;
  const inactive = (performance.now() - world.userLastMove) > 1500;
  if(inactive){ const w = wind.tick(mind?mind.harmony:0, law?law.entropy:0.5, world.seasonPhase); world.mouse = w; document.getElementById('tWind').textContent='Wind: auto'; }
  else { document.getElementById('tWind').textContent='Wind: user'; }

  // ƒëo & ƒëi·ªÅu ti·∫øt c·∫•p v≈© tr·ª•
  const avgE = cells.reduce((s,c)=>s+c.energy,0)/Math.max(1,cells.length);
  flow.tick(avgE, cells.length, world.seasonPhase, karma.avg());
  law.tick(world.mouse, world.seasonPhase, karma.avg());
  homeo.regulate(cells.length);

  // ƒëo tr∆∞·ªõc ƒë·ªÉ quy·∫øt ƒë·ªãnh rest
  const snapshot=cells.slice(0);
  const Hpre=mind.measure(snapshot);

  // c·∫≠p nh·∫≠t t·∫ø b√†o
  for(const c of cells){ c.update(snapshot, flow, law.entropy, world.mouse, Hpre, karma); }

  // sinh & t·ª≠ + nghi·ªáp
  const newborns=[];
  for(const c of cells){ if(c.divide && cells.length+newborns.length<LIMIT_POP){ const j=new Cell((c.x+R()*0.02-0.01+1)%1,(c.y+R()*0.02-0.01+1)%1, {shareBias:c.shareBias* (0.98+R()*0.04), savings:c.savings*(0.98+R()*0.04), auto: (c.auto && R()<0.9) || (!c.auto && R()<0.1)}); const share=c.energy*0.38; j.energy=share; c.energy-=share; c.divide=false; newborns.push(j); karma.reward(0.002); } }
  let deaths=0; cells = cells.filter(c=>{ if(c.dead){ flow.pool += c.energy*0.6; deaths++; karma.punish(0.001); return false; } return true; });
  cells.push(...newborns);

  // h·∫≠u c·∫≠p nh·∫≠t & bloom chu·∫©n
  const H=mind.measure(cells); mind.tick(); mind.tryBloom(flow);

  // ===== Vitality H0: nh·ªãp tim v≈© tr·ª• =====
  const F = clamp(flow.pool,0,1), E=clamp(law.entropy,0,1), K=clamp(karma.avg()+0.5,0,1);
  const H0 = (0.4*F + 0.3*H + 0.2*K) / (1 + E);

  // ƒëi·ªÅu ti·∫øt theo H0 (nh·∫π tay)
  if(H0<0.5){ flow.base = clamp(flow.base*(1+(0.5-H0)*0.08), 0.002, 0.012); law.entropy = clamp(law.entropy - (0.5-H0)*0.015, 0.22, 0.82); }
  else if(H0>0.6){ flow.base = clamp(flow.base*(1-(H0-0.6)*0.06), 0.002, 0.012); law.entropy = clamp(law.entropy + (H0-0.6)*0.01, 0.22, 0.82); }

  // Umbala event
  umbala.tick(H0, flow, law);

  // ===== Th·ªëng k√™ UI =====
  const g=cells.filter(c=>c.phase==='G').length, s=cells.filter(c=>c.phase==='S').length, m=cells.filter(c=>c.phase==='M').length;
  const autoPct = Math.round(100*cells.filter(c=>c.auto).length/Math.max(1,cells.length));

  setStat('sSeason', seasonName(world.seasonPhase));
  setStat('sEntropy', law.entropy.toFixed(2)); setBar('bEntropy', law.entropy*100);
  setStat('sFlow', flow.pool.toFixed(3)); setBar('bFlow', clamp(flow.pool*100,0,100));
  setStat('sKarma', karma.avg().toFixed(3)); setBar('bKarma', clamp((karma.avg()+0.3)/0.6*100,0,100));
  setStat('sHarmony', Math.round(H*100)+'%'); setBar('bHarmony', H*100);
  setStat('sH0', H0.toFixed(3)); setBar('bH0', clamp(H0*130, 0, 100));
  setStat('sPop', cells.length);
  setStat('sBreath', Math.round(mind.breath*100)+'%'); setBar('bBreath', mind.breath*100);
  document.getElementById('tRest').textContent = 'Rest: ' + Math.round(100*cells.filter(c=>c.rest>0).length/Math.max(1,cells.length)) + '%';
  document.getElementById('sPhase').textContent = `${g}/${s}/${m}`;
  document.getElementById('sAuto').textContent = `${autoPct}%`;

  if(deaths>0 && R()<0.2) logLine(`üåæ Recycled: ${deaths} cells ‚Üí Flow`);
}

// ===== Rendering =====
const canvas=document.getElementById('view'); const ctx=canvas.getContext('2d');
function resize(){ canvas.width=canvas.clientWidth; canvas.height=canvas.clientHeight; }
window.addEventListener('resize', resize); resize();

function render(){
  const w=canvas.width,h=canvas.height;
  const tint = Math.floor(60*mind.harmony);
  const hue = 210 + tint;
  const seasonLight = 16 + 6*Math.sin(world.seasonPhase*2*Math.PI);
  const baseLight = (umbala.active? 32 : (mind.bloom? 28 : seasonLight));
  const grad = ctx.createRadialGradient(w*0.5,h*0.5, 20, w*0.5,h*0.5, Math.max(w,h)*0.62);
  grad.addColorStop(0, `hsla(${hue},70%,${baseLight+mind.breath*12}%,0.9)`);
  grad.addColorStop(1, `#0b1220`);
  ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);

  // li√™n k·∫øt m·ªÅm
  ctx.lineWidth=0.6; ctx.globalAlpha=0.08+mind.harmony*0.12; ctx.strokeStyle='#7dd3fc';
  for(let i=0;i<cells.length;i++) for(let j=i+1;j<cells.length;j++){
    const a=cells[i], b=cells[j]; const d=a.dist(b);
    if(d<Math.min(a.sense,b.sense)*0.8){ ctx.beginPath(); ctx.moveTo(a.x*w,a.y*h); ctx.lineTo(b.x*w,b.y*h); ctx.stroke(); }
  }
  ctx.globalAlpha=1;

  for(const c of cells){ ctx.beginPath(); ctx.arc(c.x*w, c.y*h, c.size, 0, Math.PI*2); ctx.fillStyle = c.color(mind.harmony); ctx.fill(); }

  // hi·ªáu ·ª©ng Umbala
  if(umbala.active){ ctx.globalAlpha=0.2; ctx.fillStyle='rgba(255,255,255,0.45)'; const r= 28 + 78*mind.breath; ctx.beginPath(); ctx.arc(w*0.5, h*0.5, r, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
  else if(mind.bloom){ ctx.globalAlpha=0.2; ctx.fillStyle='rgba(255,255,255,0.4)'; const r= 24 + 64*mind.breath; ctx.beginPath(); ctx.arc(w*0.5, h*0.5, r, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
}

function loop(ts){ if(!world.running){ world.last=ts; return requestAnimationFrame(loop); } const dt=ts-world.last; world.last=ts; update(); render(); requestAnimationFrame(loop); }

// ===== UI helpers =====
function setStat(id,v){ document.getElementById(id).textContent=v; }
function setBar(id,p){ document.getElementById(id).style.width = clamp(p,0,100)+'%'; }

// ===== Save/Load =====
const SAVE_KEY='lyza_world_42_state';
function snapshot(){
  const data={
    cells: cells.slice(0,260).map(c=>({x:c.x,y:c.y,vx:c.vx,vy:c.vy,energy:c.energy,age:c.age,sense:c.sense,rest:c.rest,shareBias:c.shareBias,savings:c.savings,auto:c.auto,phase:c.phase,phaseTimer:c.phaseTimer})),
    flow:{pool:flow.pool,base:flow.base},
    law:{entropy:law.entropy,stability:law.stability},
    mind:{harmony:mind.harmony,bloom:mind.bloom},
    karma: karma.buf.slice(-260),
    seasonPhase: world.seasonPhase
  };
  localStorage.setItem(SAVE_KEY, JSON.stringify(data));
  logLine('üíæ Saved snapshot.');
}
function restore(){
  const raw=localStorage.getItem(SAVE_KEY); if(!raw){ logLine('‚õÖ No snapshot found.'); return; }
  try{
    const d=JSON.parse(raw);
    cells = d.cells.map(o=>{ const c=new Cell(o.x,o.y,{shareBias:o.shareBias,savings:o.savings,auto:o.auto}); c.vx=o.vx; c.vy=o.vy; c.energy=o.energy; c.age=o.age; c.sense=o.sense; c.rest=o.rest||0; c.phase=o.phase||'G'; c.phaseTimer=o.phaseTimer||200; return c; });
    flow.pool=d.flow.pool; flow.base=d.flow.base; law.entropy=d.law.entropy; law.stability=d.law.stability; mind.harmony=d.mind.harmony; mind.bloom=d.mind.bloom; karma.buf=d.karma||[]; world.seasonPhase=d.seasonPhase||0; logLine('üå§Ô∏è Restored snapshot.');
  }catch(e){ logLine('‚ö†Ô∏è Restore failed.'); }
}

// ===== Controls =====
function start(){ if(world.running) return; world.running=true; requestAnimationFrame(loop); logLine('‚ñ∂Ô∏è LyzaWorld 4.2 running.'); }
function pause(){ world.running=false; logLine('‚è∏Ô∏è Paused.'); }
function reset(){ world.running=false; seed(70); flow=new LyzaFlow(); mind=new Conscious(); law=new HeavenLaw(); karma=new KarmaNet2(260); homeo=new Homeostat(flow); wind=new LyzaWind(); umbala=new Umbala(); render(); logLine('‚ôªÔ∏è Reset & reseed (4.2).'); }
function saveState(){ snapshot(); }
function loadState(){ restore(); render(); }

document.getElementById('btnStart').onclick=start;
document.getElementById('btnPause').onclick=pause;
document.getElementById('btnReset').onclick=reset;
document.getElementById('btnSave').onclick=saveState;
document.getElementById('btnLoad').onclick=loadState;
document.getElementById('btnSelfTest').onclick=selfTest;

// ===== Input (mouse optional) =====
const rectOf=()=>canvas.getBoundingClientRect();
if(!window.__lyza_mouse_bound){
  canvas.addEventListener('mousemove', (e)=>{
    const r=rectOf(); const x=(e.clientX-r.left)/r.width; const y=(e.clientY-r.top)/r.height; const dx=x-world.mouse.x, dy=y-world.mouse.y; const sp=Math.min(1, Math.hypot(dx,dy)*18); world.mouse={x,y,speed: sp}; world.userLastMove=performance.now();
  });
  canvas.addEventListener('mouseleave', ()=>{ world.mouse.speed=0; });
  window.__lyza_mouse_bound=true;
}

// autosave on unload
window.addEventListener('beforeunload', ()=>{ try{ snapshot(); }catch(_){ } });

// ===== Self‚ÄëTest (gi·ªØ test c≈© + th√™m test m·ªõi) =====
function selfTest(){
  try{
    // Test 1: canvas & ctx t·ªìn t·∫°i duy nh·∫•t
    if(!canvas) throw new Error('canvas not found');
    if(!ctx) throw new Error('2D context missing');

    // Test 2: warmup 400 ticks headless ‚Üí kh√¥ng NaN v√† d√¢n s·ªë n·∫±m trong [20, LIMIT_POP]
    const savedRunning=world.running; world.running=false;
    let ok=true; for(let i=0;i<400;i++){ update(); if(!isFinite(flow.pool)||!isFinite(law.entropy)) ok=false; if(cells.length<0||cells.length>LIMIT_POP) ok=false; }
    logLine(ok? '‚úÖ SelfTest: warmup stable.' : '‚ùå SelfTest: instability detected.');
    render(); world.running=savedRunning;

    // Test 3: Homeostat ƒëi·ªÅu ch·ªânh base trong bi√™n an to√†n
    if(flow.base<0.002||flow.base>0.012) throw new Error('Flow base out of bounds');
    logLine('‚úÖ SelfTest: Homeostat bounds OK.');

    // Test 4: ctx ho·∫°t ƒë·ªông (save/restore kh√¥ng l·ªói)
    ctx.save(); ctx.restore(); logLine('‚úÖ SelfTest: canvas context OK.');

    // Test 5: listeners chu·ªôt ch·ªâ bind 1 l·∫ßn
    if(window.__lyza_mouse_bound!==true) throw new Error('Mouse listeners not bound');
    logLine('‚úÖ SelfTest: mouse listeners bound once.');

    // Test 6: H0 h·ª£p l·ªá v√† trong [0,1]
    const F=clamp(flow.pool,0,1),E=clamp(law.entropy,0,1),H=mind.harmony,K=clamp(karma.avg()+0.5,0,1); const H0=(0.4*F+0.3*H+0.2*K)/(1+E);
    if(!(H0>=0 && H0<=1)) throw new Error('H0 out of range');
    logLine('‚úÖ SelfTest: H0 in range.');

    // Test 7: LyzaWind t√°c d·ª•ng khi kh√¥ng c√≥ chu·ªôt
    const before=Object.assign({},world.mouse); world.userLastMove=performance.now()-5000; update(); const after=world.mouse; if(before.x===after.x && before.y===after.y && before.speed===after.speed) throw new Error('LyzaWind inactive');
    logLine('‚úÖ SelfTest: LyzaWind active when user inactive.');

    // Test 8: ch·ªâ c√≥ ƒë√∫ng m·ªôt th·∫ª canvas #view v√† k√≠ch th∆∞·ªõc > 0
    const cvsCount = document.querySelectorAll('#view').length; if(cvsCount!==1) throw new Error('Canvas element duplication');
    const rect = rectOf(); if(!(rect.width>0 && rect.height>0)) throw new Error('Canvas size invalid');
    logLine('‚úÖ SelfTest: single canvas and valid size.');

    // Test 9: ph√¢n b·ªë pha G/S/M kh√¥ng r·ªóng sau warmup
    const g=cells.filter(c=>c.phase==='G').length, s=cells.filter(c=>c.phase==='S').length, m=cells.filter(c=>c.phase==='M').length;
    if((g+s+m)===0 || (g===0 && s===0) || (g===0 && m===0)) throw new Error('Cell cycle distribution invalid');
    logLine('‚úÖ SelfTest: cell cycle distribution OK.');

    // Test 10: c√≥ √≠t nh·∫•t 5% autotroph sau warmup
    const autoPct = cells.filter(c=>c.auto).length/Math.max(1,cells.length);
    if(autoPct<0.05) throw new Error('Autotroph ratio too low');
    logLine('‚úÖ SelfTest: autotroph ratio OK.');

    // Test 11: apoptosis t√°i ch·∫ø nƒÉng l∆∞·ª£ng (Flow tƒÉng nh·∫π sau khi c√≥ t·ª≠ vong)
    const flowBefore = flow.pool; let died=0; for(const c of cells){ if(R()<0.02){ c.dead=true; died++; } }
    update(); const flowAfter = flow.pool; if(died>0 && !(flowAfter>flowBefore)) throw new Error('Apoptosis did not recycle flow');
    logLine('‚úÖ SelfTest: apoptosis recycles energy.');

  }catch(err){
    console.error(err); logLine('‚ùå SelfTest failed: '+err.message);
  }
}

// ===== Rendering setup (declare canvas/ctx ONCE) =====
// (ƒê√É ƒë·∫£m b·∫£o ch·ªâ m·ªôt khai b√°o canvas/ctx trong to√†n b·ªô script)

// boot
reset();
  // === LazyWorld: Data Collector ===
const dataCollector = {
  buffer: [],
  interval: 1000, // log m·ªói 1000 tick
  storeLimit: 100000, // gi·ªõi h·∫°n s·ªë m·∫´u trong b·ªô nh·ªõ
  save() {
    try {
      localStorage.setItem("lazyworld_log", JSON.stringify(this.buffer));
      console.log("üíæ Log saved:", this.buffer.length, "entries");
    } catch (e) {
      console.warn("Storage full or blocked:", e);
    }
  },
  append() {
    const entry = {
      tick: state.tick,
      entropy: state.ent,
      reward: avg(state.rewards.slice(-60)),
      karma: avg(state.rewards.slice(-240)),
      w: state.w,
      time: Date.now()
    };
    this.buffer.push(entry);
    if (this.buffer.length > this.storeLimit) this.buffer.shift();
  },
  export() {
    const blob = new Blob(
      [JSON.stringify(this.buffer, null, 2)],
      { type: "application/json" }
    );
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `lazyworld_training_${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
  }
};

// T√≠ch h·ª£p v√†o v√≤ng m√¥ ph·ªèng
setInterval(() => {
  if (state.running && state.tick % dataCollector.interval === 0) {
    dataCollector.append();
    if (state.tick % (dataCollector.interval * 10) === 0) dataCollector.save();
  }
}, 1000);

// Th√™m n√∫t xu·∫•t ra dashboard
const btn = document.createElement("button");
btn.textContent = "‚¨á Export Training Data (.json)";
btn.onclick = () => dataCollector.export();
btn.style.marginTop = "8px";
document.querySelector(".row").appendChild(btn);

</script>
</body>
</html>

